---
type: Apply Intelligently
description: Code organization, naming conventions, and patterns for C# backend and JavaScript frontend
---

# Code Organization & Patterns

## Backend (C#)

### Naming Conventions
- Classes: PascalCase (e.g., `VideoAnalyzerService`)
- Methods: PascalCase (e.g., `AnalyzeVideoAsync`)
- Variables: camelCase (e.g., `videoPath`)
- Private fields: `_camelCase` (e.g., `_logger`)

### Service Pattern
- All business logic in service classes
- Services registered in `Program.cs` via dependency injection
- Use constructor injection for dependencies
- Services are scoped appropriately (Scoped, Singleton, Transient)

**Example:** See `Services/VideoAnalyzerService.cs` for service pattern:
```csharp
public class VideoAnalyzerService
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<VideoAnalyzerService> _logger;
    
    public VideoAnalyzerService(
        IConfiguration configuration,
        ILogger<VideoAnalyzerService> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }
}
```

**Registration in `Program.cs`:**
```csharp
builder.Services.AddScoped<VideoAnalyzerService>();
```

### Controller Pattern
- Controllers are thin - delegate to services
- Handle HTTP concerns only
- Consistent error handling and logging
- RESTful API design

**Example:** See `Controllers/ServarrController.cs`:
```csharp
[ApiController]
[Route("api/[controller]")]
public class ServarrController : ControllerBase
{
    private readonly VideoServarrMatcherService _matcherService;
    
    [HttpPost("match-videos")]
    public async Task<ActionResult> MatchVideosWithServarr()
    {
        try
        {
            var result = await _matcherService.MatchAllVideosAsync();
            return Ok(new { matched = result });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error matching videos");
            return StatusCode(500, new { error = ex.Message });
        }
    }
}
```

### Database
- Use Entity Framework Core
- Models in `Models/` directory
- DbContext in `Data/AppDbContext.cs`
- Always create migration scripts for schema changes
- SQLite has limited ALTER TABLE support - use table recreation pattern

### Error Handling
- Use try-catch blocks in services
- Log errors with context
- Return appropriate HTTP status codes
- Provide user-friendly error messages

### Logging
- Use Serilog with structured logging
- Log levels: Information, Warning, Error, Fatal
- Include context in log messages (use structured logging)

**Examples:**
- Information: `_logger.LogInformation("Matched {MatchedCount} videos out of {TotalVideos}", matched, total)`
- Warning: `_logger.LogWarning(ex, "Error loading episode file {EpisodeFileId} for series {SeriesId}", episodeFileId, seriesId)`
- Error: `_logger.LogError(ex, "Error matching videos with Servarr")`

**Reference:** See `Services/VideoServarrMatcherService.cs` for logging patterns

## Frontend (JavaScript)

### Module Pattern
- Each JavaScript file is a self-contained ES6 module
- Use `export`/`import` for module communication
- Functions needed by HTML `onclick` handlers must be assigned to `window` object

**Example from `wwwroot/js/servarr.js`:**
```javascript
export async function matchVideosWithServarr() {
    // Implementation
}

// Export to window for onclick handlers
window.matchVideosWithServarr = matchVideosWithServarr;
```

**Reference:** See `wwwroot/js/servarr.js` for complete module pattern examples

### API Communication
- Use `fetch` API for all backend communication
- Always handle errors with try-catch
- Check `response.ok` before parsing JSON
- Provide user feedback for long-running operations

**Example from `wwwroot/js/servarr.js`:**
```javascript
try {
    const response = await fetch('/api/servarr/match-videos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    });
    
    if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Request failed');
    }
    
    const result = await response.json();
    // Handle success
} catch (error) {
    console.error('Error:', error);
    alert(`Error: ${error.message}`);
}
```

**Reference:** See `wwwroot/js/servarr.js` for complete API communication patterns

### UI Updates
- Use event-driven updates
- Show loading states for async operations
- Provide clear error messages to users
- Use consistent styling (Servarr dark theme)

## CSS

### Theme Variables
- Use CSS custom properties (variables) defined in `:root`
- Follow Servarr-style dark theme
- Colors: `--bg-primary`, `--bg-secondary`, `--text-primary`, `--accent-color`, etc.

### Responsive Design
- Use media queries for breakpoints
- Mobile-first approach
- Test on different screen sizes
